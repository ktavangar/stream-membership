Creating Models
===============

This module contains the classes from which all models will be created. The models are used to recreate different stream components.
Most of the models are spline-based and track stream or background properties (:math:`\phi_2, \mu_{\phi_1}, \mu_{\phi_2}`), as a function of :math:`\phi_1$`.

Generic Functions for all Models
--------------------------------
The generic functions are stored in the :class:`ModelMixin` class. They include plotting functions to visualize the
model projections (:func:`plot_model_projections`) and the residuals relative to the data (:func:`plot_residual_projections`).
They also include the functionality in :func:`_get_grids_2d` to create a dictionary of 2D grids from a dictionary of 1D grids in each stream parameter
(e.g.
:math:`\phi_1,  \mu_{\phi_1}, \mu_{\phi_2}`
).
This is critical because the models are being created in two-dimensional spaces (e.g. :math:`\phi_1-\phi_2`) and
we need to evaluate the model on a grid in those spaces.

Example
~~~~~~~
.. code-block:: python

    from stream_memberships.models import ModelMixin
    import numpy as np

    # Create a dictionary of 1D grids
    grids_1d = {'phi1': np.linspace(-10, 10, 100),
                'phi2': np.linspace(-10, 10, 100),
                'mu_phi1': np.linspace(-10, 10, 100),
                'mu_phi2': np.linspace(-10, 10, 100)}

    # Define the names of the 2D grid coordinates
    grid_coord_names = [('phi1', 'phi2'),
                        ('phi1', 'mu_phi1'),
                        ('phi1', 'mu_phi2')]

    # Create a dictionary of 2D grids
    grid_dict_2d = ModelMixin._get_grids_2d(grids_1d, grid_coord_names)

    # Print the keys of the 2D grid dictionary
    print(grid_dict_2d.keys())

    # Print the shape of the 2D grid dictionary
    print(grid_dict_2d['phi1'].shape)

Creating Model Components
-------------------------

The :class:`ModelComponent` class is the base class for all model components. It inherits the :class:`ModelMixin` and :class:`equinox.Module` classes,
the latter of which takes models and makes them `dataclasses <https://docs.python.org/3/library/dataclasses.html>`_ and
`pytrees <https://jax.readthedocs.io/en/latest/pytrees.html>`_.
The :class:`ModelComponent` class is used to create the different components of the model (e.g. ``background``, ``stream``, ``offtrack``)
by interfacing with numpyro behind-the-scenes.
It is also used to sample from the component's probability distribution and return the log-density of the model component at a given coordinate.

Example
~~~~~~~
This example was mostly generated by Github copilot and has not yet been checked.

.. code-block:: python

    from stream_memberships.models import ModelComponent
    import numpyro.distributions as dist

    # Define the distributions for the model component
    coord_distributions = {'phi1': dist.Uniform(-10, 10),
                           'phi2': dist.Normal(0, 1),
                           'mu_phi1': dist.Normal(-6, 1),
                           'mu_phi2': dist.Normal(3, 1)}

    # Define the parameters for the distributions
    coord_parameters = {'phi2': {'loc': 0, 'scale': 1},
                        'mu_phi1': {'loc': -6, 'scale': 1},
                        'mu_phi2': {'loc': 3, 'scale': 1}}

    # Create the model component
    model_component = ModelComponent(name='stream',
                                     coord_distributions=coord_distributions,
                                     coord_parameters=coord_parameters,
                                     default_x_coord='phi1')

    # Print the names of the component parameters
    print(model_component._coord_names)

    # Print the order in which the component parameters should be sampled
    print(model_component._sample_order)

    # Print the default x-coordinate for the model component
    print(model_component.default_x_coord)

    # Print the conditional data for the model component
    print(model_component.conditional_data)

    # Print the distributions for the model component
    print(model_component.coord_distributions)

    # Print the parameters for the distributions
    print(model_component.coord_parameters)

    # Print the name of the model component
    print(model_component.name)

    # Print the model component
    print(model_component)

    samp = model_component.sample(key = jax.random.PRNGKey(0),
                                  sample_shape = (1000,),
                                  pars=None)
    print(samp)
    plot(samp) #pseudocode

    eval = model_component.evaluate_on_2d_grids(pars=None, grids=None, grid_coord_names=None, x_coord_name=None) #change the None values
    print(eval)
    plto(eval) #pseudocode

.. The ``ModelComponent`` class has the following attributes which it takes in as parameters:

.. * ``name`` \: str
..             the name of the model component (usually either ``background``, ``stream``, or ``offtrack``)

.. * ``coord_distributions`` \: dict[str | tuple, Any]
..                           a dictionary of the distributions of the component parameters.
..                           The keys are the names of the component parameters
..                           (e.g. ```'phi1'```, ``'phi2'``, ``'mu_phi1'```, ``'mu_phi2'``, ``('phi1', 'phi2')```, etc.)

..                           and the values are numpyro distributions of those parameters.
.. * ``coord_parameters`` \: dict[str \| tuple, dict[str, dist.Distribution \| tuple \| ArrayLike \| dict]]
..                         a dictionary of the parameters of the distributions in ``coord_distributions```.
..                         The keys are the names of the component parameters (the keys in ``coord_distributions```)
..                         and the values are dictionaries containing the parameters for the distributions.
..                         For example, a truncated normal distribution (``dist.TruncatedNormal``` in ```numpyro```)
..                         might have the parameters ``loc``, ``scale``, ``low``, and ``high``.

.. * ``default_x_coord`` \: str | None = None
..                        (optional) the default x-coordinate for the model component

.. * ``conditional_data`` \: dict[str | tuple[str, str], dict[str, str]] = eqx.field(default=None)
..                         (optional) a dictionary of any additional data that is required for evaluating the
..                         log-probability of a coordinate's probability distribution. For example, a
..                         spline-enabled distribution might require the phi1 data to evaluate the spline
..                         at the phi1 values.
..                         The keys are the names of the component parameters
..                         (e.g. ``'phi1'``, ``'phi2'```, ``'mu_phi1'``, ``'mu_phi2'``, ``('phi1', 'phi2')``, etc.)
..                         and the values are dictionaries of the conditional data for those parameters.

.. It also has two other attributes which are defined during initialization with ``__post_init__``:

.. * ``_coord_names`` \: list[str] = eqx.field(init=False)`
..                       the names of the component parameters (the keys in ``coord_distributions`` and ``coord_parameters``)

.. * ``_sample_order`` \: list[str | tuple[str, str]] = eqx.field(init=False)
..                        the order in which the component parameters should be sampled




Creating a Mixture Model From Multiple Components
-------------------------------------------------

The :class:`ComponentMixtureModel` class is used to create a mixture model from multiple components defined with the :class:`ModelComponent` class.

Example
~~~~~~~
This example was mostly generated by Github copilot and has not yet been checked.

.. code-block:: python

    from stream_memberships.models import ComponentMixtureModel
    import numpyro.distributions as dist

    # Define the mixing probabilities for the model components
    mixing_probs = dist.Dirichlet([1, 1, 1])

    # Define the model components
    components = [ModelComponent(name='stream',
                                 coord_distributions={'phi1': dist.Uniform(-10, 10),
                                                      'phi2': dist.Normal(0, 1),
                                                      'mu_phi1': dist.Normal(-6, 1),
                                                      'mu_phi2': dist.Normal(3, 1)},
                                 coord_parameters={'phi2': {'loc': 0, 'scale': 1},
                                                   'mu_phi1': {'loc': -6, 'scale': 1},
                                                   'mu_phi2': {'loc': 3, 'scale': 1}},
                                 default_x_coord='phi1'),
                  ModelComponent(name='background',
                                 coord_distributions={'phi1': dist.Uniform(-10, 10),
                                                      'phi2': dist.Normal(-5, 2),
                                                      'mu_phi1': dist.Normal(0, 3),
                                                      'mu_phi2': dist.Uniform(-10, 10)},
                                 coord_parameters={'phi2': {'loc': -5, 'scale': 2},
                                                   'mu_phi1': {'loc': 0, 'scale': 3}},
                                 default_x_coord='phi1')]

    # Create the mixture model
    mixture_model = ComponentMixtureModel(mixing_probs=mixing_probs,
                                          components=components)

    # Print the names of the component parameters
    print(mixture_model.coord_names)

    # Print the order in which the component parameters should be sampled
    print(mixture_model._tied_order)

    # Print the components of the mixture model
    print(mixture_model._components)

    # Print the mixture model
    print(mixture_model)

    eval = model_component.evaluate_on_2d_grids(pars=None, grids=None, grid_coord_names=None, x_coord_name=None) #change the None values
    print(eval)
    plto(eval) #pseudocode


.. It has the following attributes which it takes in as parameters:

.. * ``mixing_probs`` \: dist.Dirichlet | ArrayLike
..                     the mixing probabilities of the model components

.. * ``components`` \: list[ModelComponent]
..                   a list of the model components that will be combined to create the mixture model

.. * ``tied_coordinates`` \: dict[str, dict[str, str]] = eqx.field(default=None)
..                         (optional) A dictionary of tied coordinates, where a key should be the name of a model
..                         component in the mixture, and the value should be a dictionary with keys as
..                         the names of the coordinates in the model component and values as the names
..                         of the other model component to tie that coordinate to. For example,
..                         `tied_coordinates={"offtrack": {"pm1": "stream}}` means that for the model
..                         component named `"offtrack"`, use the `"pm1"` coordinate from the `"stream"` model
..                         component.

.. It also has three other attributes which are defined during initialization with `__post_init__`:

.. * ``coord_names`` \: tuple[str] = eqx.field(init=False)
..                      the names of the component parameters (the keys in ``coord_distributions`` and ``coord_parameters`` of each individual component).
..                      Every component must have the same coordinate names so they can be combined

.. * ``_tied_order`` \: list[str] = eqx.field(init=False)
..                     Based on which coordinates are tied, the order in which the component distributions should be modeled.
..                     First, components with no dependencies are modeled, then components with dependencies are modeled.

.. * ``_components`` \: dict[str, ModelComponent] = eqx.field(init=False)
..                     a dictionary of the model components, where the keys are the names of the components and the values are the components themselves.
..                     This is just a restructuring of the input list of components into a dictionary for easier access.
